{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome my Misc Docs","text":"<p>In this Documentation, you will find a comprehensive guide on setting up CAN devices with Klipper. Klipper is a powerful open-source firmware that allows you to optimize and expand your 3D printer setups.</p> <p>In this documentation, we (DocGalaxyBlock and me) will explain in detail how to integrate CAN devices into your Klipper configuration. CAN (Controller Area Network) is a serial communication standard used in various industrial and automotive applications. By using CAN, you can establish reliable and efficient communication between your host and control components, enhancing your printing results.</p> <p>Additionally, this repository provides further specific instructions and information on Klipper. We cover exclusive guides to use Klipper specific functions. Our goal is to provide you with a comprehensive resource that enables you to unleash the full potential of Klipper.</p> <p>We are committed to regularly updating this documentation and adding new content to ensure you have the latest information. We warmly invite you to actively participate in the community, ask questions, and provide suggestions for improvement. Together, we can contribute to making Klipper and the use of CAN devices even better.</p> <p>Furthermore, we encourage you to utilize the Issue Tracker and PR (Pull Request) section of this repository to suggest improvements or report any issues you encounter while using Klipper with CAN devices. Your feedback and contributions are highly valued, and they play a vital role in enhancing the overall Klipper experience for the community. Together, let's make Klipper and CAN integration even more robust and user-friendly.</p> <p>Please feel free to open new issues or submit pull requests with your ideas, bug reports, or code contributions. We appreciate your active participation and look forward to collaborating with you to make Klipper and the CAN documentation as comprehensive and helpful as possible.</p> <p>Thank you for choosing this documentation. We hope it assists you in setting up and utilizing your Klipper-based controllers.</p> <p>Let's get started!</p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/","title":"BigTreeTech EBB","text":"<p>This is an instruction to set up the BTT EBB36, EBB42 and EBB SB2209/2240 with Klipper via CANBUS.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.1</li> <li>BTT EBB36 &amp; 42 v1.2</li> <li>BTT EBB SB2209/2240 v1.0</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p> <p>This guide will not work with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.0</li> </ul> <p>These boards have a different MCU.</p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/#ebb36-42-v11-v12","title":"EBB36 &amp; 42 v1.1 &amp; v1.2","text":"<ul> <li>official Repository for the EBB36 v1.1 &amp; v1.2<ul> <li>Schematic</li> <li>Size</li> <li>User Manual</li> </ul> </li> <li>official Repository for the EBB42 v1.1 &amp; v1.2<ul> <li>Schematic</li> <li>Size</li> <li>User Manual</li> </ul> </li> <li>Sample config v1.1</li> <li>Sample config v1.2</li> </ul>"},{"location":"3d-printing/klipper/canbus/btt/ebb/#hardware","title":"Hardware","text":"<ul> <li>MCU: ARM Cortex-M0+ STM32G0B1CBT6 64MHz whit FDCAN bus</li> <li>Stepper Dirver: Onboard TMC2209 in UART mode, UART address: 00, Rsense: 0.11R</li> <li>Onboard Accelerometer Sensor: ADXL345</li> <li>Onboard Temperature IC: Max31865 Select 2 / 4 lines PT100 / PT1000 by DIP switch (no Max31865 verson have not this feature)</li> <li>Input Voltage: DC12V-DC24V 6A</li> <li>Logic Voltage: DC 3.3V</li> <li>Heating Interface: Hotend (E0), maximum output current: 5A</li> <li>Fan Interfaces: two CNC fans (FAN0, FAN1)</li> <li>Maximum Output Current of Fan Interface: 1A, Peak Value 1.5A</li> <li>Expansion Interfaces: EndStop, I2C, Probe, RGB, PT100/PT1000, USB interface, CAN Interface</li> <li>Temperature Sensor Interface Optional: 1 Channel 100K NTC or PT1000(TH0), 1 Channel PT100/PT1000</li> <li>USB Communication Interface: USB-Type-C</li> <li>DC 5V Maximum Output Current: 1A</li> </ul>"},{"location":"3d-printing/klipper/canbus/btt/ebb/#pinout-ebb36-v11-v12","title":"Pinout EBB36 v1.1 &amp; v1.2","text":""},{"location":"3d-printing/klipper/canbus/btt/ebb/#pinout-ebb42-v11-v12","title":"Pinout EBB42 v1.1 &amp; v1.2","text":""},{"location":"3d-printing/klipper/canbus/btt/ebb/#ebb-sb22092240-v10","title":"EBB SB2209/2240 v1.0","text":"<ul> <li>official Repository for the EBB SB2209/2240 v1.0</li> <li>Sample config</li> <li>Schematic EBB SB2209</li> <li>Size EBB SB2209 Mainboard</li> <li>Size EBB SB2209 Subboard</li> <li>Schematic EBB SB2240</li> <li>Size EBB SB2240 Mainboard</li> <li>Size EBB SB2240 Subboard</li> <li>User Manual</li> </ul>"},{"location":"3d-printing/klipper/canbus/btt/ebb/#hardware_1","title":"Hardware","text":"<ul> <li>MCU: ARM Cortex-M0+ STM32G0B1CBT6 64MHz whit FDCAN bus</li> <li> <p>Stepper Dirver:</p> <ul> <li>TMC2209 Version: Onboard TMC2209 in UART mode, UART address: 00, Rsense: 0.11R</li> <li>TMC2240 Version: Onboard TMC2240 in SPI mode</li> </ul> </li> <li> <p>Onboard Accelerometer Sensor: ADXL345</p> </li> <li>Onboard Temperature IC: Max31865 Select 2 / 4 lines PT100 / PT1000 by DIP switch</li> <li>Input Voltage: DC12V-DC24V 9A</li> <li>Logic Voltage: DC 3.3V</li> <li>Heating Interface: Hotend (E0), maximum output current: 5A</li> <li> <p>Fan Interfaces:</p> <ul> <li>2 x CNC fans (FAN1, FAN2)</li> <li>1 x 4-wire fan (4W_FAN)</li> </ul> </li> <li> <p>Maximum Output Current of Fan Interface: 1A, Peak Value 1.5A</p> </li> <li>Expansion Interfaces: EndStop, Bltouch, Proximity(NPN &amp; PNP), RGB, PT100/PT1000, USB, CAN, SPI</li> <li>Temperature Sensor Interface Optional: 1 Channel 100K NTC or PT1000(TH0), 1 Channel PT100/PT1000 (Max31865)</li> <li>USB Communication Interface: USB-Type-C</li> <li>DC 5V Maximum Output Current: 1A</li> </ul>"},{"location":"3d-printing/klipper/canbus/btt/ebb/#pinout-ebb-sb2209-v10","title":"Pinout EBB SB2209 v1.0","text":""},{"location":"3d-printing/klipper/canbus/btt/ebb/#pinout-ebb-sb2240-v10","title":"Pinout EBB SB2240 v1.0","text":""},{"location":"3d-printing/klipper/canbus/btt/ebb/canboot/","title":"CanBoot bootloader (optional)","text":"<p>Canboot is a bootloader for MCUs to be able to update/flash them via CANBUS. With CanBoot there is no physical intervention (e.g. pressing the boot button) required to flash/update firmware to the MCUs.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.1</li> <li>BTT EBB36 &amp; 42 v1.2</li> <li>BTT EBB SB2209/2240 v1.0</li> </ul> <p>This guide will not work with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.0</li> </ul> <p>These boards have a different MCU.</p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/canboot/#download-canboot","title":"Download CanBoot","text":"<p>Clone the CanBoot repository: <pre><code>cd ~\ngit clone https://github.com/Arksine/CanBoot\n</code></pre> To add CanBoot to your moonraker update manager, add this section to your config (optional): moonraker.conf<pre><code>[update_manager canboot]\ntype: git_repo\norigin: https://github.com/Arksine/CanBoot.git\npath: ~/CanBoot\nis_system_service: False\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/canboot/#configure-canboot","title":"Configure CanBoot","text":"<p>Open the config dialog with the following commands: <pre><code>cd ~/CanBoot\nmake menuconfig\n</code></pre> and use following config settings:</p> <ul> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32G0B1</li> <li>Build CanBoot deployment application: 8KiB bootloader</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: CAN bus (on PB0/PB1)</li> <li>Application start offset: 8KiB offset</li> <li>CAN bus speed: 500000</li> <li>Support bootloader entry on rapid double click of reset button: check (optional but recommend)</li> <li>Enable Status LED: check</li> <li>Status LED GPIO Pin: PA13</li> </ul> <p>this should then look like this:</p> <p> </p> CanBoot config for EBB devices <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>These lines just clear the cache and compile the CanBoot bootloader: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/canboot/#flash-canboot","title":"Flash CanBoot","text":"Before you start the flashing process, disconnect the heater from the board! <p>Up to version v1.1, the heater output is switched to on in DFU mode while in this mode! This can lead to a fire! \ud83d\udd25 Like in the next picture where the door bell ringed \ud83d\udd14 In version v1.2, this pin has changed because of this issue.</p> <p> (only the printer was harmed - picture used with permission) </p> <p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply, or press the reset button on the board. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash CanBoot with the following command: <pre><code>dfu-util -a 0 -D ~/CanBoot/out/canboot.bin -s 0x08000000:mass-erase:force:leave\n</code></pre>  Now press the reset button and if the flash process was successfully one LED should blink now.</p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/canboot/#update-canboot","title":"Update CanBoot","text":"<p>If you want to update CanBoot, you have multiple possible ways to do this.</p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/canboot/#update-canboot-via-usb","title":"Update CanBoot via USB","text":"<p>If you want to update CanBoot via USB, you have to plug in a USB cable and continue with the \"old\" guide here: Flash CanBoot to the EBB</p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/canboot/#update-canboot-via-can","title":"Update CanBoot via CAN","text":"<p>Since the board can only be addressed via CAN, further CanBoot updates must also be flashed to the board via CAN. This is very easy with the CanBoot bootloader: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/CanBoot/out/canboot.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/klipper/","title":"Klipper Firmware for BigTreeTech EBB","text":"<p>The BigTreeTech EBB series is a toolhead board series that can communicate via CAN. This guide explains which settings you need, to flash your EBB boards with Klipper.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.1</li> <li>BTT EBB36 &amp; 42 v1.2</li> <li>BTT EBB SB2209/2240 v1.0</li> </ul> <p>This guide will not work with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.0</li> </ul> <p>These boards have a different MCU.</p> <p>Info</p> <p>Use at least a Klipper version of v0.10.0-531 to use the board safely! In this commit, Kevin fixed a bug in the ADC calculation of the STM32G0.</p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/klipper/#configure-klipper-firmware","title":"Configure Klipper firmware","text":"<p>Open the config interface of the Klipper firmware with following commands: <pre><code>cd ~/klipper\nmake menuconfig\n</code></pre> and set the following settings:</p> <ul> <li>Enable extra low-level configuration options: check</li> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32G0B1</li> <li>Bootloader offset: No bootloader (without CanBoot)</li> <li>Bootloader offset: 8KiB bootloader (with CanBoot)</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: CAN bus (on PB0/PB1)</li> <li>CAN bus speed: 500000</li> </ul> <p>The result should look like this:</p> <p> </p> Klipper config for EBB devices <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/klipper/#flash-klipper","title":"Flash Klipper","text":"<p>There are two ways to flash the Klipper firmware to the EBB.</p> <ul> <li>Flash the firmware via USB </li> <li>Flash the firmware via CAN (recommended) (only with CanBoot)</li> </ul>"},{"location":"3d-printing/klipper/canbus/btt/ebb/klipper/#flash-klipper-via-usb","title":"Flash Klipper via USB","text":"<p>This is the classic way to flash the firmware to the EBB.</p> Before you start the flashing process, disconnect the heater from the board! <p>Up to version v1.1, the heater output is switched to on in DFU mode while in this mode! This can lead to a fire! \ud83d\udd25 Like in the next picture where the door bell ringed \ud83d\udd14 In version v1.2, this pin has changed because of this issue.</p> <p> (only the printer was harmed - picture used with permission) </p> <p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply, or press the reset button on the board. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>It should then look like this: </p> <p>If your board is in DFU mode, you can flash Klipper with the following command: <pre><code>dfu-util -a 0 -D ~/klipper/out/klipper.bin -s 0x08000000:mass-erase:force:leave\n</code></pre> </p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/klipper/#flash-klipper-via-can","title":"Flash Klipper via CAN","text":"<p>This is the recommended way to flash the firmware, when you use CanBoot on your board.</p> <p>Find the UUID of your board: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -i can0 -q\n</code></pre> The output should look like this: </p> <p>With the UUID you have just read, you can now flash the board with: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/klipper/out/klipper.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"3d-printing/klipper/canbus/btt/ebb/klipper/#add-the-mcu-in-klipper","title":"Add the MCU in Klipper","text":"<p>Finally, you can add the board to your Klipper <code>printer.cfg</code> with its UUID: printer.cfg<pre><code>[mcu EBB]\ncanbus_uuid: &lt;uuid&gt;\n\n# embedded temperature sensor\n[temperature_sensor EBB]\nsensor_type: temperature_mcu\nsensor_mcu: EBB\nmin_temp: 0\nmax_temp: 100\n</code></pre></p> <p>If you don't know the UUID of your EBB, you can read it out with the following command: <pre><code>~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0\n</code></pre> The output should look like this: </p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-module/","title":"BigTreeTech PI v1.2 + U2C Module v1.0","text":"<p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech Pi v1.2</li> <li>U2C Module v1.0</li> </ul> <p>This guide was verified on a BigTreeTech Pi v1.2 running CB1 Debian11 Klipper</p> <p>This is an instruction to set up a BigTreeTech Pi v1.2 with a U2C Module v1.0 with Klipper. The BigTreeTech Pi v1.2 is a Raspberry Pi alternative with a H616 SoC. The U2C Module v1.0 is a USB-to-CAN adapter, which can be plugged on the top of the BigTreeTech Pi v1.2 as a HAT.</p> <p></p> <p>This module is already preconfigured &amp; flashed by BigTreeTech. Turn off the Pi, remove the power supply, and plug the module on the Pi. After the Pi is fully booted again, CAN should be ready.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-module/#using-u2c-module-v10-on-the-minimal-cb1-image","title":"Using U2C Module v1.0 on the minimal CB1 image","text":"<p>this is only needed if...</p> <p>you use the minimal image from BigTreeTech. The minimal Image have nothing preinstalled from the the Klipper enviroment.</p> <ul> <li>BigTreeTech Pi v1.2</li> <li>U2C Module v1.0</li> </ul> <p>This guide was verified on a BigTreeTech Pi v1.2 running CB1 Debian11 minimal</p> <p>On the minimal image the CAN interface must be configured first. This can be done with the <code>/etc/network/interfaces.d/can0</code> file. Follow the steps below to set them up.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/","title":"BigTreeTech U2C v1.x","text":"<p>This is an instruction to set up the BTT U2C with Klipper. There are two possible variants. Use the board as a pure CANBUS adapter (candlelight FW) or a Klipper USB-to-CAN adapter.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v1.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p> <p>There are multiple solutions to run the U2C with Klipper:</p> <ul> <li>CandleLight_FW (recommended)</li> <li>Klipper USB-to-CAN adapter</li> </ul> <p>The straightforward variant to use the U2C is the candlelight firmware. With this, very little has to be configured, and you don't have to update it with Klipper MCU updates. With the U2C, there are few advantages through the Klipper firmware since no freely assignable pins are available on the board.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/#links","title":"Links","text":"<ul> <li>official Repository for the U2C v1.x<ul> <li>Schematic v1.0</li> <li>Schematic v1.1</li> <li>User Manual</li> </ul> </li> </ul>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/#pinout","title":"Pinout","text":""},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/canboot/","title":"CanBoot bootloader (optional)","text":"<p>Canboot is a bootloader for MCUs to be able to update/flash them via CANBUS. With CanBoot there is no physical intervention (e.g. pressing the boot button) required to flash/update firmware to the MCUs.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v1.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/canboot/#download-canboot","title":"Download CanBoot","text":"<p>Clone the CanBoot repository: <pre><code>cd ~\ngit clone https://github.com/Arksine/CanBoot\n</code></pre> To add CanBoot to your moonraker update manager, add this section to your config (optional): moonraker.conf<pre><code>[update_manager canboot]\ntype: git_repo\norigin: https://github.com/Arksine/CanBoot.git\npath: ~/CanBoot\nis_system_service: False\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/canboot/#configure-canboot","title":"Configure CanBoot","text":"<p>Open the config dialog with the following commands: <pre><code>cd ~/CanBoot\nmake menuconfig\n</code></pre> and use following config settings:</p> <ul> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32F072</li> <li>Build CanBoot deployment application: 8KiB bootloader</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: USB (on PA11/PA12)</li> <li>Application start offset: 8KiB offset</li> <li>Support bootloader entry on rapid double click of reset button: check</li> <li>Enable Status LED: check</li> <li>Status LED GPIO Pin: PA14</li> </ul> <p>this should then look like this:</p> <p> </p> CanBoot config for U2C v1.x <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>These lines just clear the cache and compile the CanBoot bootloader: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/canboot/#flash-canboot","title":"Flash CanBoot","text":"<p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash CanBoot with the following command: <pre><code>dfu-util -a 0 -D ~/CanBoot/out/canboot.bin -s 0x08000000:mass-erase:force:leave\n</code></pre>  Now press the reset button and if the flash process was successfully one LED should blink now.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/canboot/#update-canboot","title":"Update CanBoot","text":"<p>If you want to update CanBoot, you have multiple possible ways to do this.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/canboot/#update-canboot-via-usb","title":"Update CanBoot via USB","text":"<p>If you want to update CanBoot via USB, you have to plug in a USB cable and continue with the \"old\" guide here: Flash CanBoot via USB</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/canboot/#update-canboot-via-can","title":"Update CanBoot via CAN","text":"<p>Since the board can only be addressed via CAN, further CanBoot updates must also be flashed to the board via CAN. This is very easy with the CanBoot bootloader: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/CanBoot/out/canboot.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/candlelight/","title":"CandleLight_FW (U2C v1.x)","text":"<p>CandleLight_FW is a firmware for STM32F042x/STM32F072xB based USB-CAN adapters.</p> <p>Github: github.com/candle-usb/candleLight_fw</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/candlelight/#compile-candlelight_fw","title":"Compile CandleLight_FW","text":"<pre><code># install requirements\nsudo apt-get install cmake gcc-arm-none-eabi\n\ncd ~\n# clone git repo\ngit clone --depth=1 https://github.com/candle-usb/candleLight_fw\ncd ~/candleLight_fw\n\n# create cmake toolchain\nmkdir build\ncd build\ncmake .. -DCMAKE_TOOLCHAIN_FILE=../cmake/gcc-arm-none-eabi-8-2019-q3-update.cmake\n\n# compile firmware\nmake candleLight_fw\n</code></pre>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/candlelight/#flash-candlelight_fw","title":"Flash CandleLight_FW","text":"<p>First, the adapter must boot in DFU mode. Please press the boot button and then connect the USB cable. With <code>dfu-util -l</code>, you can check whether the adapter is booted in DFU mode. This should look like this:</p> <p>If dfu-util can discover a board in DFU mode it should then look like this: </p> <p>If the BTT U2C has booted in DFU mode, you can flash it with this command:</p> <pre><code>make flash-candleLight_fw\n</code></pre> <p>It should then look like this: </p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/candlelight/#add-can0-interface","title":"Add can0 interface","text":"<p>Now you only have to create the interface in the OS. to do this, create the file <code>/etc/network/interfaces.d/can0</code> and fill it with the following content.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/klipper-usb-to-can/","title":"Klipper USB-to-CAN bus bridge","text":"<p>Klipper has also the posibillity to use the U2C as a USB-to-CAN bus bridge. This is a good solution if you want to use the board as a CANBUS adapter for your printer and an MCU at the same time. In the case of the BigTreeTech U2C, this solution has no advantages over the candlelight firmware, since no freely usable pins are available on the board.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v1.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/klipper-usb-to-can/#configure-klipper-firmware","title":"Configure Klipper firmware","text":"<p>Open the config interface of the Klipper firmware with following commands: <pre><code>cd ~/klipper\nmake menuconfig\n</code></pre> and set the following settings:</p> <ul> <li>Enable extra low-level configuration options: check</li> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32F072</li> <li>Bootloader offset: No bootloader (without CanBoot)</li> <li>Bootloader offset: 8KiB bootloader (with CanBoot)</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: USB to CAN bus bridge (USB on PA11/PA12)</li> <li>CAN bus interface: CAN bus (on PB8/PB9)</li> <li>CAN bus speed: 500000</li> </ul> <p>The result should look like this:</p> <p> </p> Klipper config for U2C v1.x in bridge mode <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/klipper-usb-to-can/#flash-klipper","title":"Flash Klipper","text":"<p>There are two ways to flash the Klipper firmware to the board.</p> <ul> <li>Flash the firmware via USB (without CanBoot)</li> <li>Flash the firmware via CAN (with CanBoot)</li> </ul>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/klipper-usb-to-can/#flash-klipper-via-usb","title":"Flash Klipper via USB","text":"<p>This is the classic way to flash the firmware to the board.</p> <p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>It should then look like this: </p> <p>If your board is in DFU mode, you can flash Klipper with the following command: <pre><code>dfu-util -a 0 -D ~/klipper/out/klipper.bin -s 0x08000000:mass-erase:force:leave\n</code></pre> </p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/klipper-usb-to-can/#flash-klipper-via-can","title":"Flash Klipper via CAN","text":"<p>This is the recommended way to flash the firmware, when you use CanBoot on your board.</p> <p>The U2C must be in the bootloader mode</p> <p>The status LED should blink in the bootloader mode. If not, double press the reset button to enter the bootloader mode.</p> <p>Find the UUID of your U2C: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -i can0 -q\n</code></pre> The output should look like this: </p> <p>With the UUID you have just read, you can now flash the board with: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/klipper/out/klipper.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/klipper-usb-to-can/#add-can0-interface","title":"Add can0 interface","text":"<p>Now you only have to create the interface in the OS. to do this, create the file <code>/etc/network/interfaces.d/can0</code> and fill it with the following content.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v1.x/klipper-usb-to-can/#add-the-mcu-in-klipper-optional","title":"Add the MCU in Klipper (optional)","text":"<p>Finally, you can add the board to your Klipper <code>printer.cfg</code> with its UUID: printer.cfg<pre><code>[mcu U2C]\ncanbus_uuid: &lt;uuid&gt;\n\n# embedded temperature sensor\n[temperature_sensor U2C]\nsensor_type: temperature_mcu\nsensor_mcu: U2C\nmin_temp: 0\nmax_temp: 100\n</code></pre></p> <p>If you don't know the UUID of your U2C, you can read it out with the following command: <pre><code>~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0\n</code></pre> The output should look like this: </p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/","title":"BigTreeTech U2C v2.x","text":"<p>This is an instruction to set up the BTT U2C with Klipper. There are two possible variants. Use the board as a pure CANBUS adapter (candlelight FW) or a Klipper USB-to-CAN adapter.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v2.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p> <p>There are multiple solutions to run the U2C with Klipper:</p> <ul> <li>CandleLight_FW (BTT fork) (recommended)</li> <li>Klipper USB-to-CAN</li> </ul> <p>The straightforward variant to use the U2C is the candlelight firmware. With this, very little has to be configured, and you don't have to update it with Klipper MCU updates. With the U2C, there are few advantages through the Klipper firmware since no freely assignable pins are available on the board.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/#links","title":"Links","text":"<ul> <li>official Repository for the U2C<ul> <li>Schematic v1.1   (this is the schematic for v1.1, but it is also valid for v2.x)</li> <li>User Manual   (this is the guide for v1.x, but it is also valid for v2.x)</li> </ul> </li> </ul>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/#pinout","title":"Pinout","text":""},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/canboot/","title":"CanBoot bootloader (optional)","text":"<p>Canboot is a bootloader for MCUs to be able to update/flash them via CANBUS. With CanBoot there is no physical intervention (e.g. pressing the boot button) required to flash/update firmware to the MCUs.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v2.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/canboot/#download-canboot","title":"Download CanBoot","text":"<p>Clone the CanBoot repository: <pre><code>cd ~\ngit clone https://github.com/Arksine/CanBoot\n</code></pre> To add CanBoot to your moonraker update manager, add this section to your config (optional): moonraker.conf<pre><code>[update_manager canboot]\ntype: git_repo\norigin: https://github.com/Arksine/CanBoot.git\npath: ~/CanBoot\nis_system_service: False\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/canboot/#configure-canboot","title":"Configure CanBoot","text":"<p>Open the config dialog with the following commands: <pre><code>cd ~/CanBoot\nmake menuconfig\n</code></pre> and use following config settings:</p> <ul> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32G0B1</li> <li>Build CanBoot deployment application: 8KiB bootloader</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: USB (on PA11/PA12)</li> <li>Application start offset: 8KiB offset</li> <li>Support bootloader entry on rapid double click of reset button: check</li> <li>Enable Status LED: check</li> <li>Status LED GPIO Pin: PA13</li> </ul> <p>this should then look like this:</p> <p> </p> CanBoot config for U2C v2.x <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>These lines just clear the cache and compile the CanBoot bootloader: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/canboot/#flash-canboot","title":"Flash CanBoot","text":"<p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash CanBoot with the following command: <pre><code>dfu-util -a 0 -D ~/CanBoot/out/canboot.bin -s 0x08000000:mass-erase:force:leave\n</code></pre>  Now power cycle the board if the flash process was successfully one LED should blink now.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/candlelight/","title":"CandleLight_FW (U2C v1.x)","text":"<p>But the U2C v2.x has the STM32G0B1 that currently is not supported by the official CandleLight project. Therefore, BigTreeTech created a fork of that project and added STM32G0B1 support.</p> <p>Github: github.com/bigtreetech/candleLight_fw/tree/stm32g0_support</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/candlelight/#compile-candlelight_fw-budgetcan_fw","title":"Compile CandleLight_FW (budgetcan_fw)","text":"<pre><code># install requirements\nsudo apt-get install cmake gcc-arm-none-eabi\n\ncd ~\n# clone git repo\ngit clone --depth=1 -b stm32g0_support https://github.com/bigtreetech/candleLight_fw\ncd ~/candleLight_fw\n\n# create cmake toolchain\nmkdir build\ncd build\ncmake .. -DCMAKE_TOOLCHAIN_FILE=../cmake/gcc-arm-none-eabi-8-2019-q3-update.cmake\n\n# compile firmware\nmake budgetcan_fw\n</code></pre>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/candlelight/#flash-candlelight_fw-budgetcan_fw","title":"Flash CandleLight_FW (budgetcan_fw)","text":"<p>First, the adapter must boot in DFU mode. Please press the boot button and then connect the USB cable. With <code>dfu-util -l</code>, you can check whether the adapter is booted in DFU mode. This should look like this:</p> <p>If dfu-util can discover a board in DFU mode it should then look like this: </p> <p>If the BTT U2C has booted in DFU mode, you can flash it with this command:</p> <pre><code>make flash-budgetcan_fw\n</code></pre> <p>It should then look like this: </p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/candlelight/#add-can0-interface","title":"Add can0 interface","text":"<p>Now you only have to create the interface in the OS. to do this, create the file <code>/etc/network/interfaces.d/can0</code> and fill it with the following content.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/klipper-usb-to-can/","title":"Klipper USB-to-CAN bus bridge","text":"<p>Klipper has also the posibillity to use the U2C as a USB-to-CAN bus bridge. This is a good solution if you want to use the board as a CANBUS adapter for your printer and an MCU at the same time. In the case of the BigTreeTech U2C, this solution has no advantages over the candlelight firmware, since no freely usable pins are available on the board.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v2.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/klipper-usb-to-can/#configure-klipper-firmware","title":"Configure Klipper firmware","text":"<p>Open the config interface of the Klipper firmware with following commands: <pre><code>cd ~/klipper\nmake menuconfig\n</code></pre> and set the following settings:</p> <ul> <li>Enable extra low-level configuration options: check</li> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32G0B1</li> <li>Bootloader offset: No bootloader (without CanBoot)</li> <li>Bootloader offset: 8KiB bootloader (with CanBoot)</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: USB to CAN bus bridge (USB on PA11/PA12)</li> <li>CAN bus interface: CAN bus (on PB5/PB6)</li> <li>CAN bus speed: 500000</li> </ul> <p>The result should look like this:</p> <p> </p> Klipper config for U2C v2.x in bridge mode <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/klipper-usb-to-can/#flash-klipper","title":"Flash Klipper","text":"<p>There are two ways to flash the Klipper firmware to the board.</p> <ul> <li>Flash the firmware via USB (without CanBoot)</li> <li>Flash the firmware via USB (with CanBoot)</li> </ul>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/klipper-usb-to-can/#flash-klipper-via-usb-without-canboot","title":"Flash Klipper via USB without CanBoot","text":"<p>This is the classic way to flash the firmware to the board.</p> <p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>It should then look like this: </p> <p>If your board is in DFU mode, you can flash Klipper with the following command: <pre><code>dfu-util -a 0 -D ~/klipper/out/klipper.bin -s 0x08000000:mass-erase:force:leave\n</code></pre> </p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/klipper-usb-to-can/#flash-klipper-via-usb-with-canboot","title":"Flash Klipper via USB with CanBoot","text":"<p>This method is necessary if you don't have Klipper on your board, but flashed the CanBoot firmware already.</p> <p>At first, you have to get the serial ID for your board. To do this, you have to exectute the following command: <pre><code># find your &lt;serial device&gt; full path\nls /dev/serial/by-id/*\n</code></pre></p> <p>Then you have to use this path in the following command: <pre><code># flash Klipper\npython3 ~/CanBoot/scripts/flash_can.py -f ~/klipper/out/klipper.bin -d &lt;serial device&gt;\n</code></pre> This should look like this: </p> <p>Power cycle the board and you are done.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/klipper-usb-to-can/#add-can0-interface","title":"Add can0 interface","text":"<p>Now you only have to create the interface in the OS. to do this, create the file <code>/etc/network/interfaces.d/can0</code> and fill it with the following content.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"3d-printing/klipper/canbus/btt/u2c-v2.x/klipper-usb-to-can/#add-the-mcu-in-klipper-optional","title":"Add the MCU in Klipper (optional)","text":"<p>Finally, you can add the board to your Klipper <code>printer.cfg</code> with its UUID: printer.cfg<pre><code>[mcu U2C]\ncanbus_uuid: &lt;uuid&gt;\n\n# embedded temperature sensor\n[temperature_sensor U2C]\nsensor_type: temperature_mcu\nsensor_mcu: U2C\nmin_temp: 0\nmax_temp: 100\n</code></pre></p> <p>If you don't know the UUID of your U2C, you can read it out with the following command: <pre><code>~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0\n</code></pre> The output should look like this: </p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/","title":"Mellow FLY-SHT 36/42","text":"<ul> <li>official Repository</li> <li>Schematic</li> </ul>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/#features","title":"Features","text":"<ul> <li>CAN bus connection for stable data transmission over long distances</li> <li>24 volt max input</li> <li>5 amp mosfet for heater control</li> <li>Onboard TMC2209 driver for the extruder</li> <li>Onboard ADXL345 accelerometer to measure resonance for input shaper.</li> <li>Replaceble fan MOS that supports 2 controllable fans.</li> <li>RGB Led control</li> <li>Peripheral interface: USB1, CAN1, FAN2, RGB1, Servo1, Probe1, EndStop3, PT100 4 line1(optional), Thermal1, Heater1</li> </ul>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/#fly-sht-36-v1-size","title":"Fly-SHT 36 v1 Size","text":""},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/#fly-sht-36-v1-pinout","title":"Fly-SHT 36 v1 Pinout","text":""},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/#fly-sht-36-v1-termination","title":"Fly-SHT 36 v1 Termination","text":"<p>This board need two jumpers to termination the CAN bus. </p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/#fly-sht-42-v1-size","title":"Fly-SHT 42 v1 Size","text":""},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/#fly-sht-42-v1-pinout","title":"Fly-SHT 42 v1 Pinout","text":""},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/#fly-sht-42-v1-termination","title":"Fly-SHT 42 v1 Termination","text":"<p>This board need two jumpers to termination the CAN bus. </p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/canboot/","title":"CanBoot bootloader (optional)","text":"<p>Canboot is a bootloader for MCUs to be able to update/flash them via CANBUS. With CanBoot there is no physical intervention (e.g. pressing the boot button) required to flash/update firmware to the MCUs.</p> <p>This guide is tested with the following boards:</p> <ul> <li>Mellow Fly-SHT 42 v1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/canboot/#download-canboot","title":"Download CanBoot","text":"<p>Clone the CanBoot repository: <pre><code>cd ~\ngit clone https://github.com/Arksine/CanBoot\n</code></pre> To add CanBoot to your moonraker update manager, add this section to your config (optional): moonraker.conf<pre><code>[update_manager canboot]\ntype: git_repo\norigin: https://github.com/Arksine/CanBoot.git\npath: ~/CanBoot\nis_system_service: False\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/canboot/#configure-canboot","title":"Configure CanBoot","text":"<p>Open the config dialog with the following commands: <pre><code>cd ~/CanBoot\nmake menuconfig\n</code></pre> and use following config settings:</p> <ul> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32F072</li> <li>Build CanBoot deployment application: Do not build</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: CAN bus (on PB8/PB9)</li> <li>Application start offset: 8KiB offset</li> <li>CAN bus speed: 500000</li> <li>Support bootloader entry on rapid double click of reset button: check (optional but recommend)</li> <li>Enable Status LED: check</li> <li>Status LED GPIO Pin: !PC13</li> </ul> <p>this should then look like this:</p> <p> </p> CanBoot config for Mellow FLY-SHT devices <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>These lines just clear the cache and compile the CanBoot bootloader: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/canboot/#flash-canboot","title":"Flash CanBoot","text":"<p>First, you have to put the board into DFU mode. To do this, plug in a jumper to the following pins and then plug in the usb cable: </p> <p>With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode. If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash CanBoot with the following command: <pre><code>dfu-util -a 0 -D ~/CanBoot/out/canboot.bin -s 0x08000000:mass-erase:force\n</code></pre>  Now remove the jumper and unplug &amp; plug-in the USB cable again. If the board is in CanBoot mode, the LED should blink.</p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/klipper/","title":"Klipper Firmware for Mellow Fly-SHT 36/42 v1","text":"<p>The BigTreeTech EBB series is a toolhead board series that can communicate via CAN. This guide explains which settings you need, to flash your EBB boards with Klipper.</p> <p>This guide is tested with the following boards:</p> <ul> <li>Mellow Fly-SHT 42 v1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/klipper/#configure-klipper-firmware","title":"Configure Klipper firmware","text":"<p>Open the config interface of the Klipper firmware with following commands: <pre><code>cd ~/klipper\nmake menuconfig\n</code></pre> and set the following settings:</p> <ul> <li>Enable extra low-level configuration options: check</li> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32F072</li> <li>Bootloader offset: No bootloader (without CanBoot)</li> <li>Bootloader offset: 8KiB bootloader (with CanBoot)</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: CAN bus (on PB8/PB9)</li> <li>CAN bus speed: 500000</li> </ul> <p> use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/klipper/#flash-klipper","title":"Flash Klipper","text":"<p>There are two ways to flash the Klipper firmware to the EBB.</p> <ul> <li>Flash the firmware via USB </li> <li>Flash the firmware via CAN (recommended) (only with CanBoot)</li> </ul>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/klipper/#flash-klipper-via-usb","title":"Flash Klipper via USB","text":"<p>This is the classic way to flash the firmware to the Fly-SHT.</p> <p>First, you have to put the board into DFU mode. To do this, plug in a jumper to the following pins and then plug in the usb cable: </p> <p>With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode. If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash Klipper with the following command: <pre><code>dfu-util -a 0 -D ~/klipper/out/klipper.bin -s 0x08000000:mass-erase:force\n</code></pre>  Now remove the jumper and unplug &amp; plug-in the USB cable again.</p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/klipper/#flash-klipper-via-can","title":"Flash Klipper via CAN","text":"<p>This is the recommended way to flash the firmware, when you use CanBoot on your board.</p> <p>Find the UUID of your board: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -i can0 -q\n</code></pre> The output should look like this: </p> <p>With the UUID you have just read, you can now flash the board with: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/klipper/out/klipper.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"3d-printing/klipper/canbus/mellow/fly-sht-v1/klipper/#add-the-mcu-in-klipper","title":"Add the MCU in Klipper","text":"<p>Finally, you can add the board to your Klipper <code>printer.cfg</code> with its UUID: printer.cfg<pre><code>[mcu SHT]\ncanbus_uuid: &lt;uuid&gt;\n\n# embedded temperature sensor\n[temperature_sensor SHT]\nsensor_type: temperature_mcu\nsensor_mcu: SHT\nmin_temp: 0\nmax_temp: 100\n</code></pre></p> <p>If you don't know the UUID of your SHT, you can read it out with the following command: <pre><code>~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0\n</code></pre> The output should look like this: </p>"},{"location":"3d-printing/klipper/pa-calibration-la-test/","title":"PA-Calibration with LA-Test","text":"<p>This is a fast calibration test for Pressure Advanced. The idea was from FHeilmann.</p> <p></p>"},{"location":"3d-printing/klipper/pa-calibration-la-test/#requirements","title":"Requirements","text":"<p>At first, we have to add a gcode-macro to convert the M900 LA gcode to set the Pressure Advance value. Please add the following lines in your <code>printer.cfg</code>. printer.cfg<pre><code>[gcode_macro M900]\ndescription: Set Pressure Advance\ngcode: SET_PRESSURE_ADVANCE ADVANCE={params.K|default(0)}\n</code></pre></p>"},{"location":"3d-printing/klipper/pa-calibration-la-test/#generate-g-code","title":"Generate G-code","text":"<p>Now we use the Marlin k-factor tool to generate the G-code. Here are my parameters I used to generate the pattern in the picture above.</p> <p> </p> Change Hotend, Bed-Temperature and Retraction-Distance <p> </p> Resize the bed to your size <p> </p> Change the Retract Speed to your Retract-Speed <p> </p>      Ending Value max is 1 (Bowden). If you use a Direct-Drive printer, you can set the \"Ending Value for K\" to 0.25 and     \"K-faktor Stepping\" to 0.01. If you like to print the Numbers per Line, check-in the \"Line Numbering\" (the numbers     are horrible to remove from your buildplate).    <p> </p> Change the \"Extrusion Multiplier\" for you filament <p>Fill in a Filename in the field and click on \"Generate G-code\". Modify the Start-Gcode on the right side and click on \"Download as file\".</p>"},{"location":"3d-printing/klipper/pa-calibration-la-test/#print-the-g-code","title":"Print the G-code","text":"<p>Now print the pattern and look at which line is most constant. Count the lines from below and multiply with the \"K-factor Stepping\" value. This is your perfect Pressure Advance value.</p> <p>Happy printing!</p>"},{"location":"3d-printing/klipper/ssd1306-display/","title":"Klipper with SSD1306 Display","text":"<p>The SSD1306 is a small display that can be used to display information from Klipper. The display is connected via I2C to the SBC or the MCU. The display has a resolution of 128x64 pixels and is available in different colors.</p> <p></p> <p>Because the display can be used with different SBCs or MCUs/boards, i have worked out several instructions:</p> <ul> <li>Raspberry Pi with Host MCU</li> </ul>"},{"location":"3d-printing/klipper/ssd1306-display/rpi-host-mcu/","title":"SSD1306 connected to Raspberry Pi with Host MCU","text":"<p>This guide describes how to connect a SSD1306 display to a Raspberry Pi and install a Klipper Host MCU to use the Display.</p>"},{"location":"3d-printing/klipper/ssd1306-display/rpi-host-mcu/#install-klipper-host-mcu","title":"Install Klipper Host MCU","text":"<p>At first, you have to install the service for the Klipper Host MCU. To do this, you have to execute the following commands:</p> <pre><code>cd ~/klipper/\nsudo cp ./scripts/klipper-mcu.service /etc/systemd/system/\nsudo systemctl enable klipper-mcu.service\n</code></pre> <p>After that, you have to \"flash\" the Klipper Host MCU to the Raspberry Pi. To open the Klipper Firmware configuration:</p> <pre><code>cd ~/klipper/\nmake menuconfig\n</code></pre> <p>In the menu, you have to select the following options:</p> <ul> <li>Enable extra low-level configuration options: uncheck</li> <li>Microcontroller Architecture: Linux process</li> </ul> <p>The result should look like this:  use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p> <p>To flash the Klipper Host MCU to the Raspberry Pi, you have to execute the following commands:</p> <pre><code># stop klipper service\nsudo systemctl stop klipper\n\n# flash klipper-mcu\nmake flash\n\n# start klipper-mcu service\nsudo systemctl start klipper-mcu\n\n# start klipper service\nsudo systemctl start klipper\n</code></pre> <p>Now, Klipper Host MCU is installed and running on your Raspberry Pi. To add it to your Klipper configuration, you have to add the following lines to your <code>printer.cfg</code>:</p> <pre><code>[mcu host]\nserial: /tmp/klipper_host_mcu\n</code></pre> <p>and restart Klipper.</p> <p>Permission denied error in klippy.log</p> <p>If you get the error \"Permission denied\" in the klippy.log, you have to add your user to the dialout group:</p> <pre><code>sudo usermod -a -G tty pi\n</code></pre>"},{"location":"3d-printing/klipper/ssd1306-display/rpi-host-mcu/#enable-i2c-on-raspberry-pi","title":"Enable I2C on Raspberry Pi","text":"<p>To enable the I2C interface on the Raspberry Pi, you have to execute the following commands:</p> <pre><code>echo \"dtparam=i2c_arm=on\" | sudo tee -a /boot/config.txt\necho \"i2c-dev\" | sudo tee -a /etc/modules\n</code></pre> <p>To activate the changes, you have to reboot the Raspberry Pi with <code>sudo reboot</code>.</p> <p>After the reboot, you can check if the I2C interface is enabled with the following command:</p> <pre><code>ls /dev/i2c-*\n</code></pre> <p>This should look like:</p> <p></p>"},{"location":"3d-printing/klipper/ssd1306-display/rpi-host-mcu/#connect-ssd1306-to-rpi","title":"Connect SSD1306 to RPi","text":"<p>Connect the SSD1306 display to the Raspberry Pi with the following pins:</p> <ul> <li>VCC -&gt; 3.3V (Pin 1)</li> <li>GND -&gt; GND (Pin 6)</li> <li>SCL -&gt; SCL (Pin 5)</li> <li>SDA -&gt; SDA (Pin 3)</li> </ul> <p>To check if the connection is working, you have to install the <code>i2cdetect</code> tool with:</p> <pre><code>sudo apt install i2c-tools\n</code></pre> <p>and then you can use the following command to test the connection:</p> <pre><code>sudo i2cdetect -y 1\n</code></pre> <p>This should look like:  Important is the <code>3c</code> in the output. This is the address of the SSD1306 display.</p>"},{"location":"3d-printing/klipper/ssd1306-display/rpi-host-mcu/#add-ssd1306-to-klipper-configuration","title":"Add SSD1306 to Klipper configuration","text":"<p>To add the SSD1306 display to your Klipper configuration, you have to add the following lines to your <code>printer.cfg</code>:</p> <pre><code>[display]\nlcd_type: ssd1306\ni2c_mcu: host\ni2c_bus: i2c.1\n</code></pre> <p>and restart Klipper.</p> <p>The result should look like this: </p> <p>(Yes, this looks not very nice, but it works. If you have a better screen layout for Klipper, please let me know.)</p>"},{"location":"other/snakeoil-certificates/","title":"Snakeoil Certificates","text":"<p>The snakeoil certificates are used by default in the <code>ssl-cert</code> package on Debian and Ubuntu. They are used for testing or private purposes.</p>"},{"location":"other/snakeoil-certificates/#generate-new-certificate","title":"Generate new certificate","text":"<pre><code># install dependencies\nsudo apt-get install ssl-cert\n# add pi user to ssl-cert group\nsudo adduser pi ssl-cert\n# generate new certificates\nmake-ssl-cert generate-default-snakeoil --force-overwrite\n</code></pre> <p>This will generate the following files: <pre><code># certificate\n/etc/ssl/certs/ssl-cert-snakeoil.pem\n# private key\n/etc/ssl/private/ssl-cert-snakeoil.key\n</code></pre></p>"},{"location":"other/snakeoil-certificates/#use-snakeoil-certificate-with-moonraker","title":"Use snakeoil certificate with Moonraker","text":"<p>To use the snakeoil certificate with Moonraker, you have to create symbol links to the certificate and the private key: <pre><code>ln -s /etc/ssl/certs/ssl-cert-snakeoil.pem /home/pi/printer_data/certs/moonraker.cert\nln -s /etc/ssl/private/ssl-cert-snakeoil.key /home/pi/printer_data/certs/moonraker.key\n</code></pre> after that, you have to restart Moonraker.</p>"},{"location":"other/snakeoil-certificates/#use-snakeoil-certificate-with-mainsailnginx","title":"Use snakeoil certificate with Mainsail/Nginx","text":"<p>Open your nginx config with <code>sudo nano /etc/nginx/sites-available/mainsail</code> and add the following lines: <pre><code>listen 443 ssl default_server;\nssl_certificate /etc/ssl/certs/ssl-cert-snakeoil.pem;\nssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;\n</code></pre> To restart nginx, use <code>sudo systemctl restart nginx</code>.</p> <p>Now you can open Mainsail with <code>https://&lt;your-ip&gt;</code>. You only have to \"allow\" the certificate in your browser because it is self-signed and not signed by a trusted CA.</p>"}]}